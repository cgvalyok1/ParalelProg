// Механизмы синхронизации
/*
	Необходимо задать взаимное время (шкалу) каким-то образом,
	которая замеряет очередь - какой поток и что делает.
*/

//Синхронизация потоков
/*
	- "Метод задания соответствия потоков команд во времени"
	1. Взаимное исключение - mutual exclusion (mutex) - объект ядра ОС, который позволяет разным программам синхронизироваться
		У мьютекса 2 состояния:
		владеем/свободен,
		блокирован/сигнален

	(Сети Петри используются при моделировании системы)

	Критические секции / фьютекс / спин-счётчики (функции мьютекса)
	Критическая секция позволяет выполнять следующую процедуру:
		Пока ресурс занят:
			Вытесниться
	Например, из расписания поток убирается, пока ресурс занят (циклически)

	Спин счётчики:
		пока i < 6000 и (ресурс занят):
			Вытесниться и i++;
		если i == 6000 --> поток переходит в состояние владения мьютексом
	*/

	/*

		Участок кода в OpenMP
		#pragma omp critical {
			..Здесь выполнение кода каждым потоком по-очереди
		}
		говорит о том, что участок кода должен защищаться от гонки потоков (т.е. один поток должен выполнять этот участок кода в одно время.

		omp_mutex_lock(h) - по состоянию мьютекса h можно осуществлять синхронизацию
		Покинутый mutex - тот, которому не сделали unlock().
		Mutex - это такая же память, которую необходимо освобождать.
		(Abandoned)

		2. Монитор
		Главная его задача в том, чтобы сигнализировать об определённом событии.

		События (в Win используются) - Events.
			SetEvent/ResetEvent
			WaitFor* - функция

		СемафОры
		Свободны несколько раз (это как мьютексы, только которыми можно завладеть только n-ое кол-во раз)
		Mutex - частный случай Семафоров, только который пропускает 1 поток. А Семафор может пропускать до n потоков
		Переменные условия - наиболее распространённый случай Семафоров - (condition_variable CV)
		Под условием подразумевается некоторый предикат. Если условие удовлетворено, то сигнал от монитора идёт...

		У переменных-условий есть следующий интерфейс (абстрактно):
		CV {
			wait(mtx)
			notify()
			notify_all()
		}

		Монитор работает следующим образом:
		Можно осуществить ожидание некоторого события или сигнала.
		Пусть есть потоки t = 0 и t = 1.
		Если один из потоков начинает осуществлять ожидание (cv.wait();), то поток начинает быть заблокирован, пока
		другой поток не вызовет метод cv.notify(), чтобы другой поток продолжил работу.






	*/